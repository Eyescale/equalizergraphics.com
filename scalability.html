
#define S_HOME
#define S_HOME_SCALABILITY
#define PAGE About
#define SUBPAGE Scalability
 
#define KEYWORDS "scalability Equalizer OpenGL compound decomposition recomposition 2D DB DPlex"

#include "header.html"

<h2>Scalability</h2>
<a href="#overview">Overview</a><br/>
<a href="#basic">Basic Decomposition Modes</a><br/>
<a href="#advanced">Advanced Scalability Features</a><br/>

<a name="overview"/>
<h3>Overview</h3>
<p>
Equalizer implements a wide range of task decomposition algorithms to
parallelize the rendering of large data sets. Multiple graphics cards,
processors and memory can be combined to render one OpenGL scene. The Equalizer
framework distributes the rendering task across a number of rendering units
(decomposition), collects the results and recombines them on the final view
(recomposition). 
</p>
<a href="#top">Back to top</a>

<a name="basic"/>
<h3>Basic Decomposition Modes</h3>
<p>
Equalizer uses the concept of compounds to configure the parallelization of the
rendering tasks. The following compounds are available:
<table>
  <tr>
    <td><b>2D</b> decomposes the rendering in screen-space, that is, each
        contributing rendering unit processes a tile of the final
        view. Equalizer automatically recomposes the tiles side-by-side on the
        destination view.
    </td>
    <td><a href="images/2D-big.png">
        <img src="images/2D.png" alt="A 2D compound"/>
    </a></td>
  </tr>
</table>
<table>
  <tr>
    <td><a href="images/DB-big.png">
        <img src="images/DB.png" alt="A DB compound"/>
    </a></td>
    <td><b>DB</b> decomposes the rendered database so that all rendering units
        process a part of the scene in parallel. The depth buffer
        information is used to composite the individual images correctly. Other
        re-assembly algorithms, for example depth-sorted alpha blending suitable
        for volume rendering, can be used.
    </td>
  </tr>
</table>
<table>
  <tr>
    <td><b>DPlex</b> time-multiplexes multiple rendering resources to produce a
         steady stream of output images. The rendered images are simply copied
         to the destination view. An offscreen-rendering buffer can be used on
         the destination graphics card to utilize all rendering resources.
    </td>
    <td><a href="images/DPlex-big.png">
        <img src="images/DPlex.png" alt="A DPlex compound"/>
    </a></td>
  </tr>
</table>
<table>
  <tr>
    <td><a href="images/EYE-big.png">
        <img src="images/EYE.png" alt="An Eye compound"/>
    </a></td>
    <td><b>Eye</b> compounds are used during stereo rendering. The individual
        views for each eye are assigned to different rendering units and later
        copied to the appropriate stereo buffer. For other stereo modes, such as
        red/green stereo or auto-stereo displays, a different re-assembly method
        can be used.
    </td>
  </tr>
</table>
</p>
<a href="#top">Back to top</a>

<a name="advanced"/>
<h3>Advanced Scalability Features</h3>
<p>
Equalizer implements a number of additional features to better utilize the
rendering resources with the basic decomposition modes mentioned in the previous
chapter. The following gives a short overview of some of the possible
optimisations.
</p>
<table>
  <tr>
    <td>
      <p>
        The basic decomposition schemes described above can be combined in any
        possible way to address different bottlenecks within the rendering
        process. For example, an Eye compound can be combined with a DB compound
        to first decompose the rendering for the left and right eye, and then
        further sub-decompose the rendering for each individual eye point.
      </p>
    </td>
    <td>
      <a href="images/ML-big.png">
        <img src="images/ML.png" alt="Multi-Level Compounds"/></a>
    </td>
  </tr>
</table>
<table>
  <tr>
    <td>
      <a href="images/LB-big.png">
        <img src="images/LB.png" alt="2D Load-Balancing"/></a>
    </td><td>
      <p>
        The Equalizer server can dynamically adjust the decomposition parameters
        based on the current workload distribution. This load-balancing can
        happen automatically (based on time measurements) or programatically
        (based on application input).
      </p>
    </td>
  </tr>
</table>
<table>
  <tr>
    <td>
      <p>
        Advanced load-balancing uses off-screen rendering buffers on graphics
        cards displaying the final result. These buffers contribute to the
        rendering of other output channels, enabling the optimal usage of all
        rendering units on a multi-pipe machine.
      </p>
    </td>
    <td>
      <a href="images/Cross-big.png">
        <img src="images/Cross.png" alt="Advanced Load-Balancing"/></a>
    </td>
  </tr>
</table>
<table>
  <tr>
    <td>
      <a href="images/Async-big.png">
        <img src="images/Async.png" alt="Asynchronous Execution"/></a>
    </td>
    <td>
      <p>
        Equalizer schedules the rendering resources asynchronously. Resources
        which are independent from others start rendering the next
        frame immediately after they finish a frame. By hiding the unavoidable
        imbalances in the task decomposition, this execution mode provides a
        much better resource utilisation than the traditional, frame-synchronous
        approach.<br/>
        The picture shows the tasks executed over time for a synchronous versus
        an asynchronous execution using a four-way 2D or DB decomposition.
      </p>
    </td>
  </tr>
</table>
<a href="#top">Back to top</a>

<p>
More to come...
</p>

<div class="footnote">3D models partly courtesy of 
<a href="http://www.cyberware.com">Cyberware</a>.</div>

#include "footer.html"
