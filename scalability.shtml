#define S_HOME
#define S_HOME_SCALABILITY
#define PAGE About
#define SUBPAGE Scalability
 
#define DESCRIPTION "Equalizer implements a wide range of task decomposition algorithms to parallelize the rendering of large data sets."
#define KEYWORDS "scalability, Equalizer, OpenGL, compound, decomposition, recomposition, 2D, DB, DPlex, sort-first, sort-last, parallel, direct send, binary swap"

#include "header.shtml"

<h2>Table of Contents</h2>
<p>
  <a href="#overview">Overview</a><br>
  <a href="#basic">Basic Decomposition Modes</a><br>
  <a href="#advanced">Advanced Scalability Features</a><br>
</p>

<hr><a name="overview"></a>
<h2>Overview</h2>
<p>
  Equalizer implements a wide range of task decomposition algorithms to
  parallelize the rendering of large data sets. Multiple graphics cards,
  processors and memory can be combined to render one OpenGL view. The Equalizer
  framework distributes the rendering task across a number of rendering units
  (decomposition), collects the results and recombines them on the final view
  (recomposition). The detailed design and configuration of compounds is
  described in a <a href="documents/design/compounds.html">technical
  specification</a>.
</p>
<div class="float_right"><a href="images/perf.png">
    <img src="images/perf-small.jpg" alt="Performance comparison"></a>
  <div class="label">Performance for a dual-GPU workstation</div>
</div>
<p>
  All scalability features apply to graphic clusters and multi-GPU systems in
  the same way. Multi-GPU systems have the advantadge of a shared memory, which
  eliminates the need of transferring pixel data across a network, but the
  number of GPUs per system is limited. The example on the right shows the
  performance benefit over the transparent SLI mode typically used. The first
  configuration measures the baseline performance using only a single GPU. The
  second one uses the same Equalizer configuration, but transparently
  distributed across the two GPUs by SLI.  The two remaining configurations are
  using two rendering threads in DB (sort-last) and 2D (sort-first) mode, to
  scale the rendering performance of a single view, like in SLI mode. Note that
  the pixel transfer does not yet use SLI, but is executed through main memory,
  the slowest possible path. The example used is the stock Equalizer polygon
  rendering application, using a data set of 12.6 million triangles.
</p><div class="flush_float"></div>

<hr><a name="basic"></a>
<h2>Basic Decomposition Modes</h2>

<p>
  Equalizer uses a compound tree to configure the parallelization of the
  rendering tasks. The compound tree allows a flexible configuration of the task
  decomposition. The Equalizer distribution contains numerous configuration
  files for the implemented feature set. The following parallel rendering
  algorithms can be configured:
</p>

<div class="float_right"><a href="images/2D.png">
    <img src="images/2D-small.jpg" alt="A 2D compound"></a>
  <div class="label">A sort-first compound</div>
</div>
<p>
  <b>2D</b> or sort-first decomposes the rendering in screen-space, that is,
  each contributing rendering unit processes a tile of the final view. Equalizer
  simply recomposes the tiles side-by-side on the destination view. This
  mode has a low, constant IO overhead for the image transfers and can provide
  good scalability when combined with view frustum culling. Depending on the
  application data structure, the overlap of some primitives between individual
  tiles limits the scalability of this mode, typically to around eight graphic
  cards.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/DB.png">
  <img src="images/DB-small.jpg" alt="A DB compound"></a>
  <div class="label">A sort-last compound</div>
</div>
<p>
  <b>DB</b> or sort-last decomposes the rendered database so that all rendering
  units process a part of the scene in parallel. The depth buffer information is
  used to composite the individual images correctly for polygonal data. Volume
  rendering applications use an ordered alpha-based blending to composite the
  result image. This mode provides very good scalability while having linear
  increasing IO requirements. The increasing recomposition work can be addressed
  by using parallel compositing, as described below.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/EYE.png">
  <img src="images/EYE-small.jpg" alt="An Eye compound"></a>
  <div class="label">A stereo compound</div>
</div>
<p>
  <b>Eye</b> decomposition is used during stereo rendering. The individual views
  for each eye are assigned to different rendering units and later copied to the
  appropriate stereo buffer. This modes supports a variety of stereo modes,
  including red/green anaglyphics stereo or auto-stereo displays with multiple
  eye passes. Due to the frame consistency between the eye views, this modes
  scales very good up to the number of eye passes. It is often combined with
  another mode on large-scale visualization clusters.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/DPlex.png">
    <img src="images/DPlex-small.jpg" alt="A DPlex compound"></a>
  <div class="label">A DPlex compound</div>
</div>
<p>
  <b>DPlex</b> time-multiplexes multiple rendering resources to produce a steady
  stream of output images. The rendered images are simply copied to the
  destination view. This mode provides very good scalability but introduces
  latency into the rendering. Depending on the application, the additional
  latency is compensated by the higher frame rate. The AFR (Alternate Frame
  Rendering) mode of multi-GPU systems implements this feature in hardware. This
  feature is not yet implemented.
</p><div class="flush_float"></div>

<hr><a name="advanced"></a>
<h2>Advanced Scalability Features</h2>
<p>
  Equalizer implements a number of additional features to better utilize the
  rendering resources with the basic decomposition modes mentioned in the
  previous chapter. The following gives a short overview of some of the possible
  optimisations.
</p>

<div class="float_right"><a href="images/ML.png">
    <img src="images/ML-small.jpg" alt="Multi-Level Compounds"></a>
  <div class="label">A multilevel compound</div>
</div>
<p>
  The basic decomposition schemes described above can be combined in any
  possible way to address different bottlenecks within the rendering
  process. For example, an Eye compound can be combined with a 2D compound to
  first decompose the rendering for the left and right eye, and then further
  sub-decompose the rendering for each individual eye pass. This allows to
  exploit the excellent scalability of a stereo decomposition with the ability
  to use four graphic cards to render a single stereo view.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/directSend.png">
  <img src="images/directSend-small.jpg" alt="Direct Send Parallel Compositing"></a>
  <div class="label">Data flow for direct send compositing</div>
</div>
<p>
  Equalizer supports various parallel compositing algorithms, typically used
  during DB/sort-last rendering. Due to the linear increase in pixel data, it
  becomes necessary to parallelize the compositing. The compound implementation
  of Equalizer supports various parallel sort-last compositing algorithms,
  including, but not limited to, <em>direct send</em> and <em>binary
  swap</em>. Such algorithms keep the compositing cost constant due to the
  parallelization across all rendering units. The example shows a three-node
  direct-send composition. Each rendering unit does a z-based composition of one
  tile, and sends the composited result to the destination channel.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/Async.png">
  <img src="images/Async-small.jpg" 
       alt="Synchronous vs. asynchronous execution"></a>
  <div class="label">Performance for asynchronous execution</div>
</div>
<p>
  Equalizer schedules the rendering resources asynchronously. Resources which
  are independent from others start rendering the next frame immediately after
  they finish a frame. By hiding the unavoidable imbalances in the task
  decomposition, this execution mode provides a much better resource utilisation
  than the traditional, frame-synchronous approach. The picture shows the
  performance for a sort-last direct-send compound on five nodes using 1GBit
  ethernet for a latency from 0 (synchronous execution) to 6. Allowing one or
  two frames of latency increases the performance by 15 percent in this case.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/LB.png">
  <img src="images/LB-small.jpg" alt="2D Load-Balancing"></a>
  <div class="label">Load balancing a sort-first compound</div>
</div>
<p>
  The Equalizer server can dynamically adjust the decomposition parameters based
  on the current workload distribution. This load balancing can happen
  automatically (based on time measurements) or programatically (based on
  application input). This feature is not yet implemented.
</p><div class="flush_float"></div>

<div class="float_right"><a href="images/Cross.png">
  <img src="images/Cross-small.jpg" alt="Advanced Load-Balancing"></a>
  <div class="label">Advanced load balancing</div>
</div>
<p>
  Advanced load balancing uses off-screen rendering buffers on the same graphic
  cards which display the final result. These buffers contribute to the
  rendering of other output channels, enabling the optimal usage of all
  rendering units on a multi-GPU machine. This feature is not yet implemented.
</p><div class="flush_float"></div>

<div class="footnote">
3D models partly courtesy of <a href="http://www.cyberware.com">Cyberware</a>
and <a href="http://graphics.stanford.edu/data/3Dscanrep/">Stanford University
Computer Graphics Laboratory</a>.
</div>

#include "footer.shtml"
<!-- $Id$ -->
