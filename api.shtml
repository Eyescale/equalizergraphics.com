#define S_HOME
#define S_HOME_API
#define PAGE About
#define SUBPAGE Programming Interface
 
#define KEYWORDS "overview API Equalizer OpenGL scalable cluster visualization"

#include "header.shtml"

<table>
  <tr>
    <td>
      <p>
        Equalizer uses a callback-driven interface. Applications provide their
        rendering methods, which are called by the Equalizer framework according
        to the current configuration and system load. Process and thread
        creation, task synchronization and network connections are externalized
        from the application and handled by the Equalizer framework.
      </p><p>
        The multipipe programming interface of Equalizer follows the natural
        execution model of any multipipe application. In order to port an
        application to run in a  multipipe environment, the rendering routines
        have to be separated from the core application. The Equalizer framework
        will then take care of the multiprocessing and synchronization and call
        the application-provided rendering methods in parallel. The basic
        execution flow of a singlepipe and a multipipe application is show on
        the right (click on picture to enlarge).
      </p>
    </td>
    <td><a href="images/executionFlow.png">
        <img src="images/executionFlow-small.png" 
             alt="Execution flow of a singlepipe and a multipipe application">
    </a></td>
  </tr>
</table>
<p>
Equalizer abstracts common graphic entities into C++ classes, for example:
</p>
<ul>
  <li><b>Node</b> - a single computer in the cluster</li>
  <li><b>Pipe</b> - a graphics card and rendering thread</li>
  <li><b>Window</b> - an OpenGL drawable</li>
  <li><b>Channel</b> - a viewport within a window</li>
</ul>
<p>
The application subclasses these entities, and overrides methods to provide
the application's rendering code. Each method corresponds to a task, and
for all of them Equalizer provides a default method which implements the typical
use case. This allows a quick start for the developer, which can replace the
defaults gradually with his own code. The 
<a href="documents/design/taskMethods.html">full list of task methods</a>
is part of the <a href="doc_developer.html">developer documentation</a>.
Some of the most important methods are:
</p><ul>
  <li><a href="documents/design/taskMethods.html#channeldraw"><b>Channel::draw</b></a>
    - render using the provided frustum, viewport and range</li>
  <li><a href="documents/design/taskMethods.html#windowinit"><b>Window::init</b></a>
    - initialize OpenGL drawable and state</li>
  <li><a href="documents/design/taskMethods.html#pipestartframe"><b>Pipe::startFrame</b></a>
    - update frame-specific data</li>
  <li><a href="documents/design/taskMethods.html#nodeinit"><b>Node::init</b></a>
    - initialize per node application data</li>
</ul><p>
Equalizer provides an API to build network-distributed applications. In contrast
to other cluster API's, such as MPI or PVM, this API is designed for the
development of interactive applications. Certain characteristics of
visualization software, e.g. the frame-driven rendering, are exploited for
better performance and simpler programming interface.
</p><p>
API documentation for specific features, and other technical information is
available under <a href="doc_developer.html">developer documentation</a>.
</p>

#include "footer.shtml"
<!-- $Id$ -->
