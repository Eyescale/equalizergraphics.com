<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta name="description" content="Equalizer Get the best performance from your visualization cluster Latest version at http://www.equalizergraphics.com/documents/Equalizer.pdf Outline High-performance visualization Transparent and semi-transparent solutions Programming interfaces Equalizer Components Features What is HPV ? High-Performance Visualization - like HPC but for interactive 3D applications  Address the demand to visualize huge data sets using COTS clusters Issue is to scale rendering performance using multiple GPU’s and CPU’s HPC Analogy HPC	HPV What?	Parallelize computation across multiple CPU’s	Parallelize 3D rendering across multiple GPU’s and CPU’s How?	Mostly non-interactive batch processing	Highly interactive, real-time rendering Hardware	Cluster or Supercomputers typically using fast interconnects	Graphic Cluster, Supercomputers, display hardware, input devices  HPV Today Transparent and semi-transparent solutions Programming interfaces Equalizer HPV Transparent Solutions Chromium, ModViz VGP, OMP, ... Operate on OpenGL command stream (HPC analogy: auto-parallelizing compilers) Provide programming extensions for improved performance and scalability (semi-transparent) HPV Transparent Solutions Transparent Semi-Transparent HPV Programming Interfaces ScaleViz, Vega Prime, VTK Impose overall programming model and data structure (HPC analogy: CFD codes) Best for developing new applications Cavelib, VRJuggler, MPK Limited to HPV-critical areas of the code (HPC analogy: MPI, PVM) Best for porting existing applications Equalizer A Programming Interface and Resource Management System  for Scalable Graphics Applications Equalizer Programming Interface Applications are written against a client library which abstracts the interface to the execution environment  Minimally invasive programming approach Abstracts multi-processing, synchronisation and data transport Supports distributed rendering and performs frame compositing Resource Management System Applications are deployed by a server which balances the resource usage across the system Centralizes the setup for all applications  Configures application and deploys render clients Dynamic load-balancing of the cluster resources  Equalizer Tools Configuration Dynamic reconfiguration of the server Monitoring Resource usage, bandwidth utilization, statistics Profiling Execution flow, data distribution Equalizer Components Equalizer Vision Xdmx: X11 single virtual screen Chromium: OpenGL single virtual screen Equalizer: Scalable rendering engine Selected Use Cases Equalizer Features Runtime configuration Runtime scalability Minimally invasive Asynchronous execution Clusters and SSI Open Source (LGPL) Runtime Configuration Hierarchical resource description: Node→Pipe→Window→Channel Node: single system of the cluster Pipe: graphic card Window: drawable and context Channel: view Resource usage: compound tree Runtime Scalability Parallel execution of the application’s rendering code One thread per graphic card Decomposition of rendering for one view Server can choose and adapts configurations based on system resources, topology and load Runtime Scalability Sort-first (2D), sort-last (DB), time-multiplex (DPlex), stereo (eye) Flexible configuration of decomposition and recomposition Later: automatic loadbalancing Supports compositing hardware Hardware-specific optimizations 2D/Sort-First Scales fillrate Scales geometry when used with efficient view frustum culling Parallel overhead due to primitive overlap limits scalability DB/Sort-Last Scales all aspects of rendering pipeline Application needs to be adapted to render subrange of data Recomposition relatively expensive DPlex/Time-Multiplex Good scalability and loadbalancing Increased latency may be an issue Not yet implemented Eye Compound Stereo rendering Active, passive and anaglyphic stereo Excellent loadbalancing Limited by number of eye views Multilevel Compounds Compounds allow any combination of modes Combine different algorithm to address and balance bottlenecks Flexible configuration of recomposition algorithm Minimally Invasive “Make everything as simple as possible, but not simpler.&quot; --  Albert Einstein  Porting is as easy as possible Work is limited to visualization-relevant parts Simpler approaches compromise performance Asynchronous Execution Source channels start rendering the next frame early Hides imbalance in load distribution Only visible channels belonging to the same view are synchronized Greatly improves scalability on bigger pipe counts Asynchronous Execution Example: 5-node sort-last, direct-send 15% speedup, no loadbalancing DB 0 1 2 3 4 latency 6 FPS SSI and Clusters Supercomputers are just tightly integrated clusters Equalizer runs on both architectures Overall model is the same Shared memory systems allow additional optimisations Porting for SSI simpler than full port Open Source LGPL license Open standard for parallel rendering User-driven development Latest version available on: www.equalizergraphics.com Get in touch"/>
    <title></title>
    <script type="text/javascript" language="javascript">
//      <![CDATA[
            var images = new Array (29);
            images[0] = "Equalizer.html_files/Equalizer.001.jpg";
            images[1] = "Equalizer.html_files/Equalizer.002.jpg";
            images[2] = "Equalizer.html_files/Equalizer.003.jpg";
            images[3] = "Equalizer.html_files/Equalizer.004.jpg";
            images[4] = "Equalizer.html_files/Equalizer.005.jpg";
            images[5] = "Equalizer.html_files/Equalizer.006.jpg";
            images[6] = "Equalizer.html_files/Equalizer.007.jpg";
            images[7] = "Equalizer.html_files/Equalizer.008.jpg";
            images[8] = "Equalizer.html_files/Equalizer.009.jpg";
            images[9] = "Equalizer.html_files/Equalizer.010.jpg";
            images[10] = "Equalizer.html_files/Equalizer.011.jpg";
            images[11] = "Equalizer.html_files/Equalizer.012.jpg";
            images[12] = "Equalizer.html_files/Equalizer.013.jpg";
            images[13] = "Equalizer.html_files/Equalizer.014.jpg";
            images[14] = "Equalizer.html_files/Equalizer.015.jpg";
            images[15] = "Equalizer.html_files/Equalizer.016.jpg";
            images[16] = "Equalizer.html_files/Equalizer.017.jpg";
            images[17] = "Equalizer.html_files/Equalizer.018.jpg";
            images[18] = "Equalizer.html_files/Equalizer.019.jpg";
            images[19] = "Equalizer.html_files/Equalizer.020.jpg";
            images[20] = "Equalizer.html_files/Equalizer.021.jpg";
            images[21] = "Equalizer.html_files/Equalizer.022.jpg";
            images[22] = "Equalizer.html_files/Equalizer.023.jpg";
            images[23] = "Equalizer.html_files/Equalizer.024.jpg";
            images[24] = "Equalizer.html_files/Equalizer.025.jpg";
            images[25] = "Equalizer.html_files/Equalizer.026.jpg";
            images[26] = "Equalizer.html_files/Equalizer.027.jpg";
            images[27] = "Equalizer.html_files/Equalizer.028.jpg";
            images[28] = "Equalizer.html_files/Equalizer.029.jpg";
            var index = 0;
            function WindowLoaded(evt)
            {
                document.body.onselectstart = function () { return false; };
            }
            function Step(i)
            {
                GoTo(index + i)
            }
            function GoTo(newIndex)
            {
                if(newIndex >= 0 && newIndex < images.length)
                {
                    index = newIndex;
                    document.Slideshow.src = images[index];
                }
            }
//      ]]>
    </script>
</head>
<body bgcolor="black" onload='WindowLoaded(event);'>
    <p align="center">
        <br/>
        <br/>
        <img name="Slideshow" alt="" src="Equalizer.html_files/Equalizer.001.jpg" onclick="Step(1)"/>
        <br/>
        <br/>
        <input type="image" src="Equalizer.html_files/home.png" onclick="GoTo(0)"/>
        &nbsp;&nbsp;&nbsp;
        <input type="image" src="Equalizer.html_files/prev.png" onclick="Step(-1)"/>
        <input type="image" src="Equalizer.html_files/next.png" onclick="Step(1)"/>
    </p>
</body>
</html>