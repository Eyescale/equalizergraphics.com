#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Event Handling

#include "header.shtml"

<p>
  Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
  State: 
  <ul>
    <li>GLX implemented in 0.2</li>
    <li>WGL implemented in 0.3</li>
    <li>AGL in progress in svn</li>
    <li>Message pump configuration in svn</li>
</p>

<h2>X11/glX Implementation</h2>
<div class="float_right">
  <a href="documents/design/images/eventHandling.png">
    <img src="documents/design/images/eventHandling-small.jpg" 
         alt="Event Handling Sequence Diagram"/></a>
  <div class="label">Event Handling Call Flow</div>
</div>
<p>
  Equalizer implements a basic event handling mechanism, simplifying the
  development of small-sized to medium-sized applications. Complex applications
  will implement their own event handling, and disable the event handling in
  Equalizer.
</p><p>
  Equalizer uses a single, separate event thread for all pipes and windows on
  a given node. The event thread registers for events of all windows, and
  asynchronously processes events to allow both event-driven and
  continous-update execution.
</p><p>
</p><p> When the event thread receives an event from the window system, it finds
  the associated <code>eq::Window</code> and creates a
  generic <code>WindowEvent</code> from the system-specific event. The generic
  event contains the system-specific event, i.e., the X11 Event, and is passed
  to <code>Window::processEvent</code>. The default implementation
  of <code>Window::processEvent</code> transform the window event into
  a <code>ConfigEvent</code>, which is sent to the application thread
  using <code>Config::sendEvent</code>. Since the config event is potentially
  transferred to another node, it no longer contains the system-specific event.
</p><p>
  At the end of the frame, <code>Config::endFrame</code>
  calls <code>Config::processEvent</code> on each queued event. The default
  implementation is empty, the <code>eqPly</code> example implements some basic
  mouse and keyboard interaction.
</p><p>
  The exit phase is not shown in the above sequence diagram for simplicity. The
  windows and pipes are removed in the reverse order. When no entities are left
  to be handled, the event thread automatically terminates. It will restart upon
  the new initialisation of a pipe.
</p>

<h2>WGL (Win32) Implementation</h2>
<p>
  The Windows implementation of event handling differs from the X11 version in
  that no separate event thread is used. Instead, Windows messages are received
  by the pipe thread responsible for the window, and passed through the same
  processing chain as X11 events. The application event processing code is
  system-agnostic.
</p>
<p>
  The event dispatch is implemented by subclassing
  <a href="/cgi-bin/viewvc.cgi/trunk/src/lib/net/commandQueue.cpp?view=markup">eqNet::CommandQueue</a> 
  into a 
  <a href="/cgi-bin/viewvc.cgi/trunk/src/lib/net/commandQueue.cpp?view=markup">eq::CommandQueue</a>
  which 'pumps' events on every pop operation. The CommandQueue is used between
  the receiver and the rendering threads to dispatch the received
  commands. Consequently, events are only processed in between task
  commands. The WGL implementation pumps events in each node and pipe thread.
</p>

<h2>AGL (OS X Carbon) Implementation</h2>
<p>
  The AGL implementation is similar to the WGL implementation. It also does not
  use a separate event thread, but uses the eq::CommandQueue in the node thread
  to dispatch the events from the <em>main</em> application thread only, since
  Carbon events are send to this thread. The events are received in
  <a href="/cgi-bin/viewvc.cgi/trunk/src/lib/client/aglEventHandler.cpp?view=markup">AGLEventHandler</a>,
  but further event procession is not yet implemented.
</p>

<h2>External Message Pump (WGL/AGL)</h2>
<p>
  Equalizer dispatches the window system events automatically between the
  execution of two task methods. External toolkits, e.g., QT, might implement a
  message pump themselves. It is therefore desirable to disable the message pump
  for application and/or pipe threads to avoid side effect of event dispatch at
  an unexpected time for the external toolkit.
</p>
<p>
  The virtual method useMessagePump is called by Equalizer during application
  and pipe thread initialization (before configInit!) to determine if the
  application or pipe thread shall automatically dispatch OS events. For
  non-threaded pipes, the method is not called. On WGL, messages are dispatch in
  the application and each pipe thread. On AGL, events are dispatched only on
  the application thread, i.e., Pipe::useMessagePump is never called. On GLX, a
  message pump is not needed. If useMessagePump returns false, the application
  has to dispatch events.
</p>

<h2>Costumized Event Handling</h2>
<p>
  The application can provide its own event handler implementation
  in <code>Pipe::configInitEventHandler</code>
  and <code>Window::configInitEventHandler</code>. Typically these methods are
  overwritten to disable Equalizer's event handling by providing an empty
  implementation.
</p>

<h2>API</h2>
<!-- /* --><pre>
  virtual bool Window::processEvent( const WindowEvent& event );
  void Config::sendEvent( ConfigEvent& event );

  const ConfigEvent* Config::nextEvent();
  bool Config::checkEvent() const;
  virtual void Config::handleEvents();
  virtual bool Config::handleEvent( const ConfigEvent* event );

  class WindowEvent;
  struct ConfigEvent;

  virtual bool Client::useMessagePump() { return true; }
  virtual bool Pipe::useMessagePump()   { return true; }

  virtual void Pipe::configInitEventHandler();
  virtual void Pipe::configExitEventHandler();
  virtual void Window::configInitEventHandler();
  virtual void Window::configExitEventHandler();
</pre><!-- */ -->

<h2>Open Issues</h2>
<p>
  Finish and document AGL event handling.
</p>

#include "footer.shtml"
<!-- $Id$ -->
