#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE View Management

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
State:
<ul>
  <li>Implemented in 0.6</li>
  <li>Redesign in progress</li> 
</ul>

<h2>Overview</h2>
<p>
  The purpose of the management layer is to provide a programming interface and
  file format for describing the visible content of an application, i.e., what
  are my projection surfaces, which data is visible in which part of the
  projection surface and how are the views updated.
</p>
<div class="float_left">
  <a href="/documents/design/images/view.png">
    <img src="/documents/design/images/view-small.jpg" 
         alt="View Entities"/></a>
  <div class="label">Relationship of View Entities</div>
</div>
<p>
  A typical system setup consists of one or more
  projection <b>canvas</b>es. Desktop windows are considered a projection
  canvas in this context.
</p>
<p>
  Each canvas is made of one or more <b>segment</b>s. Segments can
  be planar or non-planar to each other, and can overlap or have gaps between
  each other. A segment is referencing a <b>channel</b>, which defines the
  output area of this segment, e.g., on a DVI connector connected to a
  projector.
</p>
<p>
  A canvas can define a frustum, which will create default, planar
  sub-frusta for its segments. A segment can also define a frustum, which
  overrides the canvas frustum, e.g., for non-planar setups (CAVE, curved
  screen). These frusta typically describe a physically-correct display setup
  for Virtual Reality installations.
<p>
  On each canvas, the application can display one or more <b>view</b>s. A view
  is a view on a model, in the sense used by the MVC pattern. It can be a scene,
  viewing mode, viewing position, or any other representation of the
  application's data.
</p>
<p>
  A <b>layout</b> groups one or more views which logically belong together. A
  layout is applied to a canvas. If no layout is applied to a canvas, nothing is
  rendered on this canvas, i.e, the canvas is inactive. The layout assignment
  can be changed at run-time by the application. The intersection between views
  and segments defines which output (sub-)channels are available. These output
  channels are typically used as <b>destination channels</b> in
  a <b>compound</b>. They are automatically created during configuration loading
  or creation.
</p>
<p>
  Each view can have a frustum description. The view's frustum overrides frusta
  specified at the canvas or segment level. This is typically used for
  non-physically correct rendering, e.g., to compare two models side-by-side. If
  the view does not specify a frustum, the corresponding destination channels
  will use the sub-frustum resulting from the view/segment intersection.
</p>
<p>
  A configuration file has to specify compounds (rendering instructions) for all
  destination channels. The currently used (active) layouts on the canvas(es)
  define which compounds are active, that is, for which compound channels
  rendering tasks are generated.
</p>
<p>
  Switching a layout at run-time will cause the deletion, creation, exit and
  initialization of channels, and potentially windows...nodes on the affected
  render clients.
</p>
<p>
  An <b>observer</b> looks at one or more views. It is described by the observer
  position in the world and it's eye separation. Each observer has its own
  stereo mode, focus distance and frame loop (framerate).
</p>

<h2>File Format</h2>
<!-- /* --><pre>
config
{
    node { pipe { window { channel { ...output and source channels... }}}}

    observer  # later
    {
        name    "observer1"
        eyeBase float
    }

    layout  # 1...n times
    {
        name "layout1"
        view  # 1...n times
        {
            name     "view1"
            viewport [ x y w h ]
            wall/projection {...}
            observer "observer1"  # later
        }
    }

    canvas  # 1...n times
    {
        name   "display_wall"
        layout "layout1"
        wall/projection {...}
        
        segment # 1...n times
        {
            channel  "output-channel"
            name     "segment1"
            viewport [ x y w h ]
            wall/projection {...}
        }
    }

    compound
    {
        channel "output-channel.layout1.view1"
        ...
    }
    compound  # inactive (incl. all children)
    {
        channel "output-channel.layout2.view1"
        ...
    }
}
</pre><!-- */ -->

<h2>API</h2>
<!-- /* --><pre>
     class Config
     {
         const CanvasVector& getCanvases() const;
         const LayoutVector& getLayouts() const;
     };

     class Canvas
     {
         const std::string& getName() const;

         void useLayout( const Layout* layout );
         const Layout* getLayout() const;
     };

     class Layout
     {
         const std::string& getName() const;
         const ViewVector& getViews() const;
         const CanvasVector& getCanvases() const;
     };

     class View
     {
         const std::string& getName() const;
         const eq::Viewport& getViewport() const;
         const Layout& getLayout() const;

         void setWall( const Wall& wall );
         const Wall& getWall() const;
         void setProjection( const Projection& projection );
         const Projection& getProjection() const;
         View::Type getLatestView() const;
     };

     class Channel
     {
         const View& getView() const; // valid only in frameFoo()
     };
</pre><!-- */ -->

<h2>Implementation</h2>
<h3>View/Segment Intersection</h3>
<p>
  Layouts have to be specified before canvases. Setting a canvas on a config
  will generate destination channels for all existing layouts:
</p>
<!-- /* --><pre>
Config::addCanvas( canvas )
    for each layout
        for each view of layout
            for each segment of canvas
                if segment intersects view
                    find or create "channelname.layoutname.viewname"
                    set viewport to sub-viewport of segment channel
                    decrement channel activation count [inactivates channel]
                    set view on channel, add channel to view
</pre><!-- */ -->

<h3>Config Initialization</h3>
<p>
  All resouce entities are by default activated, that is, they are created with
  activation count of 1. When a resource is used as a destination channel of a
  view/segment intersection, it's activation count is decreased, that is, it isi
  deactivated. Using a layout (re-)activates the entities used in by this
  layout.
</p>
<!-- /* --><pre>
    modify Compound::accept
       Don't traverse compounds with inactive channels if activeOnly is set

    for each canvas
        if canvas uses layout
            for each segment
                for each channel named "channelName.newLayoutName.*"
                    increase channel, window, pipe, node activation count
     -> use ConfigVisitor!

  Existing init:
    for each root compound
        init compound
            for each compound in tree
                reference channel (reference window, pipe, node)
                update (init) inherit data

   for each node, pipe, window, channel
       if entity is referenced [new: and activated]
           send entity's config init task
</pre><!-- */ -->



<h3>Frustum Calculation</h3>
<p>
  The frustum priority is View, Segment, Canvas, i.e., a frustum defined on a
  view overrides segment frustum definitions, which in turn override canvas
  segment definitions.
</p>
<p>
  View frusta define projections which are by definition independent of the
  physical projection system. Layouts with frusta are typically not used for
  immersive installations.
</p>
<p>
  Segment and canvas frusta define the characteristics of a physical projection
  system. They are given by the real-world setup, and are therefore immutable
  resource descriptions which cannot be changed by the application at run-time.
</p>
<!-- /* --><pre>
  Canvas::addSegment
      if segment has no frustum and canvas has frustum
          set segment frustum = canvas frustum X segment viewport

  in CanvasInitVisitor
      ...
          for each channel named "channelName.newLayoutName.*"
              ...
              find compounds where channel is a destination channel
              set compound frustum to frustum of the channel's segment

  after CanvasInitVisitor
      for each view
          for each channel of view (set in intersection)
              for each compound using channel as destination channel
                  set compound frustum = view frustum X channel/view coverage
</pre><!-- */ -->


<h3>Channel Activation</h3>
<p>
  Channels are activated when the layout of a canvas changes. Inactive channels
  are not traversed during frame update.
</p>
<!-- /* --><pre>
Canvas::useLayout
    for each segment
        find channels "channelName.newLayoutName.*"
            for each channel
                increase channel, window, pipe, node activation count
                create and init entities which got activated
        find channels "channelName.oldLayoutName.*"
            for each channel
                decrease channel, window, pipe, node activation count
                exit and release entities with 0 activation count
</pre><!-- */ -->

<h3>Frustum Updates</h3>
<p>
  Frusta can only be changed through the view class. Setting a frustum on a View
  overrides existing canvas or segment frusta, bypassing physical descriptions
  of the display setup:
</p>
<!-- /* --><pre>
View::setFrustum
    for each channel of view (set in intersection)
        for each compound using channel as destination channel
            compute and set sub-frustum on compound
View::clear
    for each channel of view (set in intersection)
        for each compound using channel as destination channel
            compute sub-frustum from segment and set on compound
</pre><!-- */ -->
<p>
  The same calculations are to be done on Compound::init for all compounds.
</p>

<h3>Backward-Compatibility</h3>
<p>
  Each frustum (wall/projection) description on a compound generates a new
  canvas. Each destination channel of this compound sub-tree generates a
  segment, using the compound's viewport. The views and channels are connected
  like done during intersection.
</p>
<p>
  A config always has one default layout named "???". This layout is used as the
  default layout for all canvases.
</p>

<h3>Everything Else</h3>
<p>
  Remove 0.6 screen interface (replaced by View::getViewport).
</p>

<h2>Open Issues</h2>
<p>
  Observer interface will be implemented later. Right now there is one observer
  (the config).
</p>
<p>
  Are Views intended to be sub-classed, e.g., to attach model to view. If yes,
  how is eq::net::Object data distribution implemented?
</p>
<p>
  When one layout is applied to multiple canvases, and the views of the layout
  use frusta, the frusta might have the wrong aspect ratio on one of the
  canvases. Can be solved by adding the capability of specifying frusta
  aspect-ratio-aware, or by copying the layout for each canvas.
</p>

<hr></hr>
<h1>Equalizer 0.6 Implementation</h1>
<h2>Overview</h2>
<p>
  The purpose of this API is to give read and write access to the views of a
  configuration. A view is one coherent image seen by the user of an Equalizer
  application. Most commonly changed views are windowed views, i.e., views not
  belonging to a projection system.
</p>
<p>
  A configuration has one or more views. A view is determined by the frustum
  (wall or projection description), eye separation and stereo mode (on/off). A
  view is uniquely assigned to one compound and possibly one destination
  channel.
</p>
<p>
  The config's view vector is immutable. Each view is mutable, and changes take
  effect for the next frame. Changing a view makes only sense for views which
  are not linked to a physical projection system, typically views of appNode
  channels.
</p>

<h2>Implementation</h2>

<p>
  Create new eq::View class. Use this in compound for the wall, projection
  and eye base. Move eye computations to view. View is only valid if
  either wall or projection was set. The eye base is inherited from parents or
  config, and set in valid views during Compound::init.
</p>
<p>
  The eye positions are updated when the head matrix changes or the view is
  sync'ed to a new version.
</p>
<p>
  A view is a distributed object registered by the application node, which will
  modify the data at run-time. Views track their dirty status and are committed
  at the beginning of each frame. The view data has to be send to the appNode
  during config creation by the server.
</p>


<h3>Field-of-View Updates</h3>
<p>
  Currently, the wall or projection is updated by the server when a destination
  channel is resized. This update should be done by the application, since it is
  owning the view now.
</p>
<!-- /* --><pre>
  Window::processEvent receives WINDOW_RESIZE event
  window PVP is set
  channel PVP's are updated, channel RESIZE event is send

  Channel::processEvent receives CHANNEL_RESIZE event
  transforms event into VIEW_RESIZE event, containing view id
  sends event to config

  Config::processEvent receives VIEW_RESIZE event
  if base view is unknown
      create and save new base view (using view data and size)
  else
      update view using base view and new channel pvp
</pre><!-- */ -->
<p>
  Compound FOV update hint does no longer exist.
</p>

<h3>Origin for 2D Operations</h3>
<p>
  Often 3D applications perform additional 2D drawing, for example a HUD,
  statistics or a GUI. These operations are to be performed not per view, but on
  the logical view, i.e., the whole projection area. Often even non-planar
  projection systems, e.g., a curved screen, are considered as one 'flat' 2D
  view in this context.
</p>
<p>
  The origin is an arbitrary (for 3D rendering) offset of the channel with
  respect to the virtual 2D origin. Multiple channels may 'overlap' one another,
  e.g., they might have the same origin in the case of a configuration with two
  powerwalls. Each channel can query the absolute origin in pixels.
</p>
<p>
  The total size of the virtual 2D space is needed for some 2D operations. One
  configuration might have multiple 2D areas (screens), e.g., a display wall
  driven from a master (application) node. The size of a screen is automatically
  determined by Equalizer.
</p>
<p>
  The origin is configured using the origin parameter of a compound. The origin
  is the absolute position with respect to the 2D origin.
</p>
<p>
  A planar wall can be configured by using a wall description for the entire
  wall and viewports for each destination channel (segment). In this case, the
  origin can be computed automatically from the channel's pixel viewport and the
  compound's inherit viewport. A configuration might overwrite this value using
  the origin parameter, if the 2D coordinate system is not consistent with the
  planar wall coordinates.
</p>
<p>
  Although the origin is a view parameter, stored in 
  <code>eq::server::View</code>, it is not yet part of the 
  <code>eq::View</code>. The main reason is that there is currently no use case
  for setting or getting the view's origin, thus it is left out until a use case
  is presented.
</p>

<h2>API</h2>
<!-- /* --><pre>
  const ViewVector& Config::getViews();
  const View*       Channel::getView() const;
  
  class View : public net::Object
  {
  public:
      void setWall( const Wall& wall );
      const Wall& getWall() const;
      // same for Projection

      void setEyeBase( const float eyeBase );
      float getEyeBase() const;
  };

  const vmml::Vector2i& Channel::getScreenOrigin() const;
  vmml::Vector2i        Channel::getScreenSize() const;
  void                  Channel::applyScreenFrustum() const;
</pre><!-- */ -->

<h2>File Format</h2>
<p>
  Additional file format:
</p>
<!-- /* --><pre>
      compound
      {
          ...
          eye_base   float   // inherit from config
          screen     [ ID xOffset yOffset ] // absolute, default 1 AUTO AUTO
          ...
      }
</pre><!-- */ -->

<a name="Issues"></a>
<h2>Open Issues</h2>
<p>
  The eye base and head matrix describe the observer and belong together. One
  observer is using multiple views. API needs cleanup to model this
  correctly. Stereo mode not implemented. Might belong to view, observer/user,
  config or compound.
</p>
<p>
  Identification of views, i.e., which view do I want to modify and which not?
</p>
<p>
  Per-view head matrix? How to group multiple views with a single head matrix
  (i.e. Cave)?
</p>
<p>
  Camera assignment? App wants to use multiple cameras. Each camera is
  'attached' to one or more views. Solution could be to allow sub-classing of
  eq::View, which is problematic since the server has a non-subclassed slave
  instance. Another solution is to have an ObjectVersion (aka userdata) per
  view. Problem of view identication (which camera for which view) remains.
</p>

#include "footer.shtml"
<!-- $Id$ -->
