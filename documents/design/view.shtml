#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE View API

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
State: Implemented in 0.6-rc1
</p>

<h2>Overview</h2>
<p>
  The purpose of this API is to give read and write access to the views of a
  configuration. A view is one coherent image seen by the user of an Equalizer
  application. Most commonly changed views are windowed views, i.e., views not
  belonging to a projection system.
</p>
<p>
  A configuration has one or more views. A view is determined by the frustum
  (wall or projection description), eye separation and stereo mode (on/off). A
  view is uniquely assigned to one compound and possibly one destination
  channel.
</p>
<p>
  The config's view vector is immutable. Each view is mutable, and changes take
  effect for the next frame. Changing a view makes only sense for views which
  are not linked to a physical projection system, typically views of appNode
  channels.
</p>

<h2>Implementation</h2>

<p>
  Create new eq::View class. Use this in compound for the wall, projection
  and eye base. Move eye computations to view. View is only valid if
  either wall or projection was set. The eye base is inherited from parents or
  config, and set in valid views during Compound::init.
</p>
<p>
  The eye positions are updated when the head matrix changes or the view is
  sync'ed to a new version.
</p>
<p>
  A view is a distributed object registered by the application node, which will
  modify the data at run-time. Views track their dirty status and are committed
  at the beginning of each frame. The view data has to be send to the appNode
  during config creation by the server.
</p>


<h3>Field-of-View Updates</h3>
<p>
  Currently, the wall or projection is updated by the server when a destination
  channel is resized. This update should be done by the application, since it is
  owning the view now.
</p>
<!-- /* --><pre>
  Window::processEvent receives WINDOW_RESIZE event
  window PVP is set
  channel PVP's are updated, channel RESIZE event is send

  Channel::processEvent receives CHANNEL_RESIZE event
  transforms event into VIEW_RESIZE event, containing view id
  sends event to config

  Config::processEvent receives VIEW_RESIZE event
  if base view is unknown
      create and save new base view (using view data and size)
  else
      update view using base view and new channel pvp
</pre><!-- */ -->
<p>
  Compound FOV update hint does no longer exist.
</p>

<h3>Origin for 2D Operations</h3>
<p>
  Often 3D applications perform additional 2D drawing, for example a HUD,
  statistics or a GUI. These operations are to be performed not per view, but on
  the logical view, i.e., the whole projection area. Often even non-planar
  projection systems, e.g., a curved screen, are considered as one 'flat' 2D
  view in this context.
</p>
<p>
  The origin is an arbitrary (for 3D rendering) offset of the channel with
  respect to the virtual 2D origin. Multiple channels may 'overlap' one another,
  e.g., they might have the same origin in the case of a configuration with two
  powerwalls. Each channel can query the absolute origin in pixels.
</p>
<p>
  The total size of the virtual 2D space is needed for some 2D operations. One
  configuration might have multiple 2D areas (screens), e.g., a display wall
  driven from a master (application) node. The size of a screen is automatically
  determined by Equalizer.
</p>
<p>
  The origin is configured using the origin parameter of a compound. The origin
  is the absolute position with respect to the 2D origin.
</p>
<p>
  A planar wall can be configured by using a wall description for the entire
  wall and viewports for each destination channel (segment). In this case, the
  origin can be computed automatically from the channel's pixel viewport and the
  compound's inherit viewport. A configuration might overwrite this value using
  the origin parameter, if the 2D coordinate system is not consistent with the
  planar wall coordinates.
</p>
<p>
  Although the origin is a view parameter, stored in 
  <code>eq::server::View</code>, it is not yet part of the 
  <code>eq::View</code>. The main reason is that there is currently no use case
  for setting or getting the view's origin, thus it is left out until a use case
  is presented.
</p>

<h2>API</h2>
<!-- /* --><pre>
  const ViewVector& Config::getViews();
  const View*       Channel::getView() const;
  
  class View : public net::Object
  {
  public:
      void setWall( const Wall& wall );
      const Wall& getWall() const;
      // same for Projection

      void setEyeBase( const float eyeBase );
      float getEyeBase() const;
  };

  const vmml::Vector2i& Channel::getScreenOrigin() const;
  vmml::Vector2i        Channel::getScreenSize() const;
  void                  Channel::applyScreenFrustum() const;
</pre><!-- */ -->

<h2>File Format</h2>
<p>
  Additional file format:
</p>
<!-- /* --><pre>
      compound
      {
          ...
          eye_base   float   // inherit from config
          screen     [ ID xOffset yOffset ] // absolute, default 1 AUTO AUTO
          ...
      }
</pre><!-- */ -->

<a name="Issues"></a>
<h2>Open Issues</h2>
<p>
  The eye base and head matrix describe the observer and belong together. One
  observer is using multiple views. API needs cleanup to model this
  correctly. Stereo mode not implemented. Might belong to view, observer/user,
  config or compound.
</p>
<p>
  Identification of views, i.e., which view do I want to modify and which not?
</p>
<p>
  Per-view head matrix? How to group multiple views with a single head matrix
  (i.e. Cave)?
</p>
<p>
  Camera assignment? App wants to use multiple cameras. Each camera is
  'attached' to one or more views. Solution could be to allow sub-classing of
  eq::View, which is problematic since the server has a non-subclassed slave
  instance. Another solution is to have an ObjectVersion (aka userdata) per
  view. Problem of view identication (which camera for which view) remains.
</p>

#include "footer.shtml"
<!-- $Id$ -->
