
#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Volume Rendering

#include "header.shtml"
 
<p>
  Author: Makhinya Maxim<br>
  State: Design
</p>
  
<h2>Overview</h2>

<div class="float_right">
  <a href="images/volumeDB.png"><img src="images/volumeDB-small.png"
                                     alt="Volume DB decomposition"></a>
  <div class="label">Volume DB decomposition example</div>
</div>

<p>
  This document gathers some design issues around Equalizer's volume rendering
  application. A 3D texture based approach was chosen for the
  implementation. The focus is to render large volumes the volume decomposition
  using DB (sort-last) compounds.  The volume is split into bricks along one
  axis for simplicity. The recomposition of the partial, semi-transparent volume
  bricks is done using back-to front compositing.  The number of frames to
  composit equals the data bricks number, the data bricks are in strong
  correspondence to each other. We only need to transfer RGBA information, and
  we can ignore depth values on the final compositing stage, which savea network
  bandwidth.  The correct sequences of the RGBA frames for compositing is fixed,
  but Equalizer's current compositing implementation assumes that frames can be
  composed in arbitrary way. For the volume render, we will implement a user
  defined sequence of frame compositing.  This technique could be used in future
  for arbitrary semitransparent objects compositing.
</p>

<h2>Design</h2>

<div class="float_right">
  <img src="images/currentBackFront.png" alt="back to front compositing"></a>
  <div class="label">Back to front compositing for current image</div>
</div>

<h3>Semi-transparent frame compositing</h3>
<p>
  Since the current compositing implementation assumes no order, the currently
  rendered plane in the frame buffer already and we don't need to read it back
  for compositing. For volume rendering, this plane is often not the last one in
  the compositing order. There are two ways to solve the problem:
</p>

<ul>
  <li>
    The channel that performs the compositing should wait for all frames that
    should be assembled before him, perform the compositing of this planes, then
    render his own data over already assembled planes, and finally assemble all
    frame which should be drawn in front of his. This process could be
    schematically described as following:
    <pre>
      clear
      assemble "pre"
      render
      assemble "post"
    </pre>

    It introduces 1 frame latency which is not a problem. However this approach
    has the following problems: only one client can perform compositing (serial
    assembly) and parallel compositing algorithms, such as direct send, couldn't
    be used. This approach could be possibly used only when semitransparent
    objects covers small area of a frame.
  </li>
  <li>
    The second approach uses a read-back of assembling area so theoretically it
    should be slower but it doesn't introduce latency and could be done in
    parallel so it will work much faster, plus it will take less effort to
    implement. Its order of operations is:
    <pre>
      clear
      render
      read-back
      assemble
    </pre>
	
    Please note that read-back should be used only for compositing area and only
    when the current brick is not the farthest one.
  </li>
</ul>

<p>
  A more detailed sequence for the second algorithm is:

  <pre>
    override Channel::frameAssembly()<br>
    - compute union of frames -> uPVP (unionn pixel viewport);<br>
    * read image of uPVP<br>
    * glClear( uPVP )<br>
    - push GL state, set up blending<br>
    - draw all frames ordered (range and current transformation matrix
      should be used to obtain correct assembling sequence)<br>
    - restore GL state<br>
    * free/recycle image
  </pre>

  Stages marked with (*) should be performed only when the current 
  brick is not the farthest one. The assembly stage should be omitted 
  in case of 2D (Sort First) composition. 
</p>

<h2>Implementation</h2>
<p>
  TBD
</p>

<h2>API</h2>
<p>
  TBD
</p>
   
<h2>File Format</h2>
<!-- /* --><pre>
  TBD
</pre><!-- */ -->
  
<h2>Open Issues</h2>
<p>
</p>
   
#include "footer.shtml"
<!-- $Id$ -->
