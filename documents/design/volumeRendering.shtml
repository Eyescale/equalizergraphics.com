
#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Volume Rendering

#include "header.shtml"
 
<p>
  Author: Makhinya Maxim<br>
  State: Design
</p>
  
<h2>Overview</h2>

<div class="float_right">
  <a href="images/volumeDB.png"><img src="images/volumeDB-small.png"
                                     alt="Volume DB decomposition"></a>
  <div class="label">Volume DB decomposition example</div>
</div>

<p>
  Volume rendering equalizer's application is in development stage for 
  now, 3D texture based approach was chosen for implementation. Due to 
  render large volumes the volume decomposition (DB decomposition) is 
  required. In order to use the equalizer scalability the task of 
  semi-transparent planes back-to front compositing has to be solved. 
  Splitting of volume to slices performed only in one axes direction 
  for simplicity. The number of planes to compose equals to data slices 
  number, the data slices are in strong correspondence to each others 
  and we can ignore depth values on the final compositing stage in 
  order to save network bandwidth, in this case correct sequences of 
  compositing is fixed, but current implementation of compositing 
  stage assumes that planes could be composed in arbitrary way. Our 
  task is to implement user defined sequence of planes compositing. 
  This technic could be used in future for arbitrary semitransparent 
  objects compositing.
</p>

<h2>Design</h2>

<div class="float_right">
  <img src="images/currentBackFront.png" alt="back to front compositing"></a>
  <div class="label">Back to front compositing for current image plane</div>
</div>

<h3>Semi-transparent planes compositing</h3>
<p>
  Current implementation of compositing assumes that currently 
  rendered plane is in the frame buffer already and we don't need to 
  read it back for compositing, but this plane could be the front one. 
  There are two ways to solve the problem:
</p>

<p>
  1) Client that perform compositing should wait for all back planes 
  that should be assembled before, then perform assembling of this 
  planes, then render his own data over already assembled planes, 
  and finally assemble all planes which should be drawn over it. This 
  process could be schematically described as following:

  <pre>
    clear
    assemble "pre"
    render
    assemble "post"
  </pre>
	
  It introduces 1 frame latency which is not a problem while 
  rendering performed on realtime speed. However this approach has 
  following problems: only one client performs compositing and Direct 
  Send technic couldn't be used (otherwise it will introduce the 
  latency of [Number_of_data_slices-1] frames) besides it will increase 
  client's complexity which is not acceptable. This approach could be 
  possibly used only when semitransparent objects covers small area of 
  a frame.
</p>

<p>
  2) Second approach used read-back of assembling area so theoretically 
  it should be slower but it doesn't introduce latency and could be 
  done in parallel so it will work much faster, plus it will take less 
  effort to implement due to less invade to the current rendering 
  process (it requires only current assembly step modification). It 
  could be described as:

  <pre>
    clear
    render
    read-back
    assemble
  </pre>
	
  Please note that read-back should be used only for compositing area 
  and only is case when current plane is not the farthest one. 
</p>

<p>
  More detailed sequence of tasks that have to be done listed bellow:

  <pre>
    override Channel::frameAssembly()<br>
    - compute union of frames -> PVP (Pixel View Port);<br>
    * read image of uPVP (united PVP)<br>
    * clean uPVP <br>
    - push state, enable blend<br>
    - draw all frames ordered (range and current transformation matrix
      should be used to obtain correct assembling sequence)<br>
    - pop state<br>
    * free image
  </pre>

  Stages marked with (*) should be performed only in case when current 
  plane is not the farthest one. The assembly stage should be omitted 
  in case of 2D (Sort First) composition. 
</p>

<h2>Implementation</h2>
<p>
  TBD
</p>

<h2>API</h2>
<p>
  TBD
</p>
   
<h2>File Format</h2>
<!-- /* --><pre>
  TBD
</pre><!-- */ -->
  
<h2>Open Issues</h2>
<p>
</p>
   
#include "footer.shtml"
<!-- $Id$ -->