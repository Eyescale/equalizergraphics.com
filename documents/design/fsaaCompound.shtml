#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Subpixel Compounds

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
State: Design
</p>

<h2>Overview</h2>
<p>
  This features adds support for a new type of decomposition and recomposition,
  whereby each contributing channel renders one or multiple subsamples for
  full-scene anti-aliasing (FSAA) or depth-of-field (DOF). 
</p>
<p>
  Applications might already do multi-pass software FSAA/DOF, either during
  rendering or when the application is idle. Equalizer does not yet have a
  notion of idle/non-idle rendering.
</p>

<h2>Design</h2>
<p>
  The application will do the adding of the frustum jitter, since it is the one
  which knows how many FSAA and/or DOF samples are desired. Therefore it needs
  to know in Channel::frameDraw which sample out of how many it should render.
</p>
<p>
  The default implementation of Channel::applyFrustum will use the subpixel
  sample description to compute an FSAA jitter using a pre-defined lookup
  table. It will add this jitter to the frustum supplied by getFrustum.
</p>
<p>
  Applications which have their own SWAA settings will use the subpixel sample
  description to calculate how many passes with which samples have to be
  rendered, e.g., if it desires to render 16 samples on a 4-time decomposition,
  the application will render 4 passes out of a 16-value jitter lookup table on
  each channel.
</p>
<p>
  It is the application's responsibility to provide a blended result of the
  sub-passes on each channel. This should not be an overhead, since the
  application could already compute the accumulation and averaging before.
</p>
<p>
  Compositing
</p>

<h2>API</h2>
<!-- /* --><pre>
  vmml::Vector2f Channel::getJitter( ??? ) const;
  vmml::Vector2i Channel::getSubpixel() const;
</pre><!-- */ -->

<h2>File Format</h2>
<!-- /* --><pre>
    compound
    {
        subpixel [ index size ]
    }
</pre><!-- */ -->

<h2>Implementation</h2>
<!-- /* --><pre>
Modify eqPly to do idle SWAA
  TBD

Eq changes:
  Channel::applyFrustum
    frustum = getFrustum()
    jitter = getJitter();
    frustum += jitter;
    glFrustum( ... );
  Compositor?

--------------------------------------------------
Current idle AA in Eq application:

  Channel::frameAssemble()
    assemble input frames into back buffer
    if view is idle
      if first idle step
        reset accum buffer
      accumulate back buffer to accum buffer
      compute average in back buffer
    
      
  Channel::frameDraw()
    if view is idle
      get idle step # and jitter frustum
    render

Idle AA with AA compounds:
  Channel::frameAssemble
    if first idle step
      reset accum buffer
    if has more than one jitter step or view is idle
      for each jitter step in input frames
        assemble input frames with jitter step in back buffer
        accumulate back buffer in accum buffer
        ++n
      compute average in back buffer
      increase application idle steps done by n
      
  Channel::frameDraw()
    jitter step = f(application idle step, Channel jitter param)
      jitter step = idle_step * jitter_grp_size + jitter_offset
    render


</pre><!-- */ -->

<a name="Issues"></a>
<h2>Issues</h2>

<h3>1. Do we need a one-dimensional or two-dimensional subpixel description for
  each source channel?</h3>
<p>
  This depends on Q2. My feeling is a one-dimensional attribute is easier.
</p>

<h3>2. How do I compute my current jitter area?</h3>
<p>
  The number of jitter areas, i.e, the number of FSAA or DOF samples, is an
  application parameter. The current jitter area within each Channel::frameDraw
  is a function of the current idle step and the channel's subpixel description.
</p>
<p>
  Open Issue: the function itself. The jitter values for all channels in the
  first pass should be evenly distributed over the total subpixel grid.
</p>

#include "footer.shtml"
<!-- $Id$ -->
